<?php


namespace App\Http\Controllers\CRM\Courier;


use App\Enums\TransactionStatus;
use App\Exceptions\Http\Controller\RequestClassNotFoundException;
use App\Http\Controllers\CRM\BaseCRMController;
use App\Http\Requests\CRM\Courier\CreateTransaction;
use App\Http\Requests\CRM\Courier\UpdateTransaction;
use App\Http\Resources\CRM\TransactionResource;
use App\Services\CRM\Courier\TransactionService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;
use Symfony\Component\HttpFoundation\Response;

/**
 * Class TransactionController
 * @package App\Http\Controllers\Web\Order
 */
class TransactionController extends BaseCRMController
{

    public function __construct(TransactionService $service)
    {
        parent::__construct($service, CreateTransaction::class, UpdateTransaction::class, TransactionResource::class);
    }

    /**
     * @return JsonResponse
     * @throws \App\Repositories\RepositoryException
     */
    public function index()
    {
        return parent::index(); // TODO: Change the autogenerated stub
    }

    /**
     * @param $id
     * @return mixed
     * @throws \App\Repositories\RepositoryException
     * @throws \ReflectionException
     */
    public function show($id)
    {
        return parent::show($id); // TODO: Change the autogenerated stub
    }


    /**
     * @param Request $request
     * @return JsonResponse
     * @throws \App\Exceptions\Http\Controller\RequestClassNotFoundException
     */
    public function store(Request $request)
    {

        $request->request->add([
            'operatorId' => auth()->user()->id,
        ]);

        return parent::store($request); // TODO: Change the autogenerated stub
    }

    /**
     * @param Request $request
     * @param $id
     * @return JsonResponse
     * @throws RequestClassNotFoundException
     * @throws \App\Repositories\RepositoryException
     * @throws \ReflectionException
     */
    public function update(Request $request, $id) : JsonResponse
    {
        $service = $this->service::findOne(['id' => $id]);

        $request->request->add([
            'id' => $id,
            'operatorId' => auth()->user()->id,
        ]);

        if ($service->getRepository()->getModel()->status->in([TransactionStatus::Completed, TransactionStatus::Confirm, TransactionStatus::Cancel])) {
            return $this->responseError('Невозможно изменить данную транзакцию', Response::HTTP_UNPROCESSABLE_ENTITY);
        }

        try {
            $request = $this->requestUpdateClass::createFrom($request);
        } catch (\Throwable $e) {
            throw new RequestClassNotFoundException('Ошибка класса валидации');
        }


        $params = $request->all();


        $validation = Validator::make($params, $request->rules(), $request->messages());

        if ($validation->fails()) {
            return $this->responseError('Неверные параметры', Response::HTTP_UNPROCESSABLE_ENTITY, $validation->errors()->toArray());
        }


        $service->edit($request->all());

        $this->data['id'] = $id;
        $this->data['message'] = 'Успещно обновлено!';

        return $this->responseSuccess($this->data);

    }

    /**
     * @param $id
     * @return JsonResponse
     * @throws \App\Repositories\RepositoryException
     * @throws \ReflectionException
     */
    public function waitTransaction($id) : JsonResponse
    {
        $service = $this->service::findOne(['id' => $id]);

        if ($service->getRepository()->getModel()->status->isNot(TransactionStatus::New)) {
            return $this->responseError('Транзакция уже ожидает курьера', Response::HTTP_UNPROCESSABLE_ENTITY);
        }

        $params = [
            'operatorId' => auth()->user()->id,
            'status' => TransactionStatus::Wait,
            'id' => $id,
        ];


        $service->edit($params);

        $this->data['id'] = $id;
        $this->data['message'] = 'Транзакция переведена в режим ожидания!';

        return $this->responseSuccess($this->data);
    }


    /**
     * @param $id
     * @return JsonResponse
     * @throws \App\Repositories\RepositoryException
     * @throws \ReflectionException
     */
    public function cancelTransaction($id)
    {
        $service = $this->service::findOne(['id' => $id]);

        $params = [
            'operatorId' => auth()->user()->id,
            'status' => TransactionStatus::Cancel,
            'id' => $id,
        ];

        if (!$service->getRepository()->getModel()->status->in([TransactionStatus::Wait,TransactionStatus::New])) {

            return $this->responseError('Невозможно отменить данную транзакцию', Response::HTTP_UNPROCESSABLE_ENTITY);
        }


        $service->edit($params);

        $this->data['id'] = $id;
        $this->data['message'] = 'Транезакция отменена!';

        return $this->responseSuccess($this->data);
    }



}
